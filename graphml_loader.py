#!/usr/bin/python

# graphml_loader
#
# This file parses Network Topologies in GraphML format from the Internet Topology Zoo.
# A python file for creating Mininet Topologies will be created as Output.
# Input files have to be in the "topologies" directory. Output files will be generated there as well.
#
# Arguments:
#   -f              [name of GraphML input file]
#   --file          [name of GraphML input file]
#   -o              [name of GraphML output file]
#   --output        [name of GraphML output file]
#
# Without any input, program will terminate.
# Without specified output, outputfile will have the same name as the input file.
# This means, the argument for the outputfile can be omitted.
# Controller ip is "192.168.1.10/24".
#
#################################################################################



import xml.etree.ElementTree as ET
import sys
import math
import re
from sys import argv

input_file_name = ''
output_file_name = ''
controller_ip = '192.168.1.10'

# first check commandline arguments
for i in range(len(argv)):

    if argv[i] == '-f':
        input_file_name = argv[i+1]
    if argv[i] == '--file':
        input_file_name = argv[i+1]
    if argv[i] == '-o':
        output_file_name = argv[i+1]
    if argv[i] == '--output':
        output_file_name = argv[i+1]

# terminate when inputfile is missing
if input_file_name == '':
    sys.exit('\n\tNo input file was specified as argument....!')

# define string fragments for output later on
outputstring_1 = '''
"""
Custom topology for Mininet, generated by GraphML-Topo-to-Mininet-Network-Generator.
"""
from mininet.topo import Topo
from rau_nodes import RAUSwitch, QuaggaRouter, RAUController, RAUHost
class CustomTopology( Topo ):
    "Internet Topology Zoo Specimen."
    def __init__(self):
        "Create a topology."
        # Initialize Topology
        Topo.__init__(self)
'''

outputstring_2a='''
        # Add controller
'''
outputstring_2a += "        "
outputstring_2a += "root = self.addHost('controller', cls=RAUController, ips=['" + controller_ip + "/24'])"
outputstring_2a += '''
        # Add management network switch
        man_switch = self.addSwitch('s1', protocols='OpenFlow13', failMode='standalone')
'''
outputstring_2b='''
        # Add switches, hosts and routers
'''

outputstring_3='''
        # Add links between nodes
'''


#WHERE TO PUT RESULTS
outputstring_to_be_exported = ''

#READ FILE AND DO ALL THE ACTUAL PARSING IN THE NEXT PARTS
xml_tree    = ET.parse("topologies/" + input_file_name)
namespace   = "{http://graphml.graphdrawing.org/xmlns}"
ns          = namespace # just doing shortcutting, namespace is needed often.

#GET ALL ELEMENTS THAT ARE PARENTS OF ELEMENTS NEEDED LATER ON
root_element    = xml_tree.getroot()
graph_element   = root_element.find(ns + 'graph')

# GET ALL ELEMENT SETS NEEDED LATER ON
index_values_set    = root_element.findall(ns + 'key')
node_set            = graph_element.findall(ns + 'node')
edge_set            = graph_element.findall(ns + 'edge')

# SET SOME VARIABLES TO SAVE FOUND DATA FIRST
# memomorize the values' ids to search for in current topology
node_label_name_in_graphml = ''
# for saving the current values
node_index_value     = ''
node_name_value      = ''
# id:value dictionaries
id_node_name_dict   = {}     # to hold all 'id: node_name' pairs
# id:type dictionaries
id_node_type_dict   = {}     # to hold all 'id: node_type' pairs
edge_with_ip_collection = []         # to hold { node1: IP_ADDRESS1, node2: IP_ADDRESS2 } elements

# FIND OUT WHAT KEY IS USED FOR THE NAME, SINCE THIS DIFFERS IN DIFFERENT GRAPHML TOPOLOGIES
for i in index_values_set:
    if i.attrib['attr.name'] == 'label' and i.attrib['for'] == 'node':
        node_label_name_in_graphml = i.attrib['id']

# INITIALIZE IP ADRESSES LIST
possible_ip_addresses = []
for i in range(1,255):
    possible_ip_addresses.append("10.10." + str(i) + ".")

# INITIALIZE MANAGEMENT IP ADDRESSES
mgmt_ip_addresses = []
for i in range(11,255):
    mgmt_ip_addresses.append("192.168.1." + str(i) + "/24")

# INITIALIZE MAC ADDRESSES LIST (this is only used for border switches)
possible_mac_addresses = []
for i in range(1,255):
    possible_mac_addresses.append("00:00:00:00:00:" + hex(i)[2:])

# NOW PARSE ELEMENT SETS TO GET THE DATA FOR THE TOPO

# GET ID: NODE_NAME MAPPINGS
for n in node_set:

    node_id = n.attrib['id']

    # first set all nodes as rauswitch
    # the ones that have 'type' set will overwrite it with the real type
    id_node_type_dict[node_id] = "rauswitch"

    #get all data elements residing under all node elements
    data_set = n.findall(ns + 'data')

    #finally get all needed values
    for d in data_set:

        #node name
        if d.attrib['key'] == node_label_name_in_graphml:
            #strip all whitespace from names so they can be used as id's
            node_name = re.sub(r'\s+', '', d.text)

            #save id:data couple
            id_node_name_dict[node_id] = node_name

        #node type
        if d.attrib['key'] == "type":
            node_type = d.text
            # save id:type to dict
            id_node_type_dict[node_id] = node_type

# GET COLLECTION OF EDGES
for e in edge_set:
    source_id = e.attrib['source']
    target_id = e.attrib['target']

    ip_address_prefix = possible_ip_addresses.pop(0)
    edge = {}
    edge[source_id] = ip_address_prefix + "1/24"
    edge[target_id] = ip_address_prefix + "2/24"

    # if one of the nodes is a switch and the other is not, then we add the mac address of the customer edge node
    # this will be used for creating the switches with the appropriate parameters when they are border switches
    if (id_node_type_dict[source_id] != "rauswitch" and id_node_type_dict[target_id] == "rauswitch") or \
        (id_node_type_dict[target_id] != "rauswitch" and id_node_type_dict[source_id] == "rauswitch"):
        edge["ce_mac_address"] = possible_mac_addresses.pop(0)

    edge_with_ip_collection.append(edge)


# NOW THAT THE DATA IS LOADED INTO THE DATA STRUCTURES
# WE CAN CREATE ALL THE REMAINING STRINGS
# BY THIS POINT, WE HAVE THE FOLLOWING STRUCTURES:
#           id_node_name_dict ===> id:name dictionary to get node names using id
#           id_node_type_dict ===> id:type dictionary to get node type (rauswitch, router, host) using id
#           edge_with_ip_collection ===> array of dictionaries with the following structure:
#                   edge1 = id1: ip_address1, id2: ip_address2, ["ce_mac_address": mac1]
#                   edge2 = id3: ip_address3, id4: ip_address4, ["ce_mac_address": mac2]
#                   ...
#                   This is indicates for each edge, what ip address each node will have, and also
#                   indicates what mac address the CE node will have, in case it is a border link
#                   if it isn't a border link, that field won't exist

# FIRST CREATE THE NODES
tempstring = ""
for i in id_node_name_dict.keys():
    node_name = id_node_name_dict[i]
    node_type = id_node_type_dict[i]
    temp1 =  "        "
    temp1 += node_name

    # we assume that the ids are integers so that the switches are named "switchX" being X an integer
    # this is necessary because the datapath-id for the switch is the integer extracted from the name
    # we add 1 to i while naming the name because some graphs may have a node with id="0" and
    # the datapath-id can't be 0 for a switch
    if node_type == "rauswitch":
        console_name = "switch" + str(int(i)+1)
    else:
        console_name = node_type + str(int(i)+1)
    node_class = "RAUSwitch"
    if node_type == "router":
        node_class = "QuaggaRouter"
    elif node_type == "host":
        node_class = "RAUHost"
    
    temp1 += " = self.addHost('" + console_name + "', cls=" + node_class + ", "
    if node_type == "rauswitch":
        temp1 += "controller_ip='" + controller_ip + "', "

    # Now we get the list of IP addresses for this node
    current_node_ip_addresses = []
    if node_type == "rauswitch":
        # The first IP address should be the management one
        # Pop the first available management address and use it for this switch
        mgmt_ip = mgmt_ip_addresses.pop(0)
        current_node_ip_addresses.append(mgmt_ip)

    # Iterate over all the edges and get this node's border edge if it has one
    # and IP addresses
    border_edge = None
    for edge in edge_with_ip_collection:
        if i in edge.keys():
            if "ce_mac_address" in edge.keys():
                border_edge = edge
            else:
                current_node_ip_addresses.append(edge[i])

    if border_edge is not None:
        if node_type == "rauswitch":
            # If it's a RAUSwitch, the border edge IP goes last in the IP list
            current_node_ip_addresses.append(border_edge[i])
        else:
            # If it's not a RAUSwitch, the border edge IP goes first in the IP list
            current_node_ip_addresses = [border_edge[i]] + current_node_ip_addresses

    temp1 += "ips=["
    for ip_addr in current_node_ip_addresses:
        temp1 += "'" + ip_addr + "'"
        if current_node_ip_addresses.index(ip_addr) != len(current_node_ip_addresses)-1:
            temp1 += ", "
    temp1 += "]"

    if border_edge is not None:
        ce_mac_address = border_edge["ce_mac_address"]
        # Iterate through the keys in the edge hash structure
        # When we find a key that is not the current node's id or "ce_mac_address"
        # That means it is the node id of the linked node
        linked_node_ip_address = None
        for key in border_edge.keys():
            if (key != i and key != "ce_mac_address") : linked_node_ip_address = border_edge[key]
        linked_node_ip_address = linked_node_ip_address.split("/")[0]

        if node_type == "rauswitch":
            temp1 += ", border=1, ce_ip_address='" + linked_node_ip_address + "', ce_mac_address='" + ce_mac_address + "'"
        else:
            temp1 += ", ce_mac_address='" + ce_mac_address + "', gw='" + linked_node_ip_address + "'"

    temp1 += ")\n"

    # Add this node to the tempstring variable
    tempstring += temp1

outputstring_2b += tempstring

# NOW CREATE THE LINKS
# FIRST THE MANAGEMENT LINKS
tempstring2 = ""
tempstring2 += "        self.addLink(man_switch, root, 1, 0)\n"
counter = 1
for i in id_node_name_dict.keys():
    if id_node_type_dict[i] == "rauswitch":
        temp2 = "        "
        counter += 1
        temp2 += "self.addLink(man_switch, " + id_node_name_dict[i] + ", " + str(counter) + ", 0)\n"

        tempstring2 += temp2

# NEXT, CREATE THE NETWORK LINKS
tempstring3 = ""

for edge in edge_with_ip_collection:
    temp3 = "        "

    keys = edge.keys()
    is_border_edge = 0
    if "ce_mac_address" in keys:
        keys.remove("ce_mac_address")
        is_border_edge = 1
    source_id = keys[0]
    target_id = keys[1]

    # Before we add the link, we have to know what number of interface corresponds to each node for this link
    source_counter = 0
    target_counter = 0
    if is_border_edge:
        # If it is a border edge, the interface counters should be:
        # - 0 for the CE node (because the corresponding IP address will be the first in the "ips" parameter)
        # - The highest number for the RAUSwitch (because the corresponding IP address will be the last in the "ips" parameter)

        # First, we need to know which of the 2 nodes is the RAUSwitch
        if id_node_type_dict[source_id] == "rauswitch":
            rauswitch_id = source_id
        else:
            rauswitch_id = target_id
        # Iterate over all the edges to know how many links the RAUSwitch has
        link_counter = 0
        for e1 in edge_with_ip_collection:
            if rauswitch_id in e1.keys():
                link_counter += 1

        if rauswitch_id == source_id:
            source_counter = link_counter
        else:
            target_counter = link_counter
    else:
        # If it is not a border edge, we have to count the previous links
        # to know what numbers this link will have
        for e2 in edge_with_ip_collection:
            if e2 == edge:
                break
            else:
                if "ce_mac_address" not in e2.keys():
                    if source_id in e2.keys():
                        source_counter += 1
                    if target_id in e2.keys():
                        target_counter += 1

        # We add 1 to the counter if the node is a RAUSwitch because the interface 0
        # is reserved for the management interface
        if id_node_type_dict[source_id] == "rauswitch":
            source_counter += 1
        if id_node_type_dict[target_id] == "rauswitch":
            target_counter += 1

        # If none of the nodes is a RAUSwitch, we have to iterate through the edges
        # To know if one of them has a border edge with a RAUSwitch
        # If it does, then the counter for that node needs to be added 1
        # Because the interface 0 (of the CE node) is reserved for the border edge interface
        if id_node_type_dict[source_id] != "rauswitch" and id_node_type_dict[target_id] != "rauswitch":
            for e3 in edge_with_ip_collection:
                if "ce_mac_address" in e3.keys():
                    if source_id in e3.keys():
                        source_counter += 1
                    if target_id in e3.keys():
                        target_counter += 1


    temp3 += "self.addLink(" + id_node_name_dict[source_id] + ", " + id_node_name_dict[target_id] + ", " + str(source_counter) + ", " + str(target_counter) + ")\n"

    tempstring3 += temp3

outputstring_3 += tempstring2
outputstring_3 += tempstring3

outputstring_to_be_exported += outputstring_1
outputstring_to_be_exported += outputstring_2a
outputstring_to_be_exported += outputstring_2b
outputstring_to_be_exported += outputstring_3

# GENERATION FINISHED, WRITE STRING TO FILE
if output_file_name == '':
    output_file_name = input_file_name + '-generated-Mininet-Topo.py'

outputfile = open("topologies/" + output_file_name, 'w')
outputfile.write(outputstring_to_be_exported)
outputfile.close()

print "Topology generation SUCCESSFUL!"