#!/usr/bin/python

# graphml_loader
#
# This file parses Network Topologies in GraphML format from the Internet Topology Zoo.
# A python file for creating Mininet Topologies will be created as Output.
# Input files have to be in the "topologies" directory. Output files will be generated there as well.
#
# Arguments:
#   -f              [name of GraphML input file]
#   --file          [name of GraphML input file]
#   -o              [name of GraphML output file]
#   --output        [name of GraphML output file]
#   -c              [controller ip as string]
#   --controller    [controller ip as string]
#
# Without any input, program will terminate.
# Without specified output, outputfile will have the same name as the input file.
# This means, the argument for the outputfile can be omitted.
# Controller ip is "192.168.1.10/24".
#
#################################################################################



import xml.etree.ElementTree as ET
import sys
import math
import re
from sys import argv

input_file_name = ''
output_file_name = ''
controller_ip = '192.168.1.10'

# first check commandline arguments
for i in range(len(argv)):

    if argv[i] == '-f':
        input_file_name = argv[i+1]
    if argv[i] == '--file':
        input_file_name = argv[i+1]
    if argv[i] == '-o':
        output_file_name = argv[i+1]
    if argv[i] == '--output':
        output_file_name = argv[i+1]

# terminate when inputfile is missing
if input_file_name == '':
    sys.exit('\n\tNo input file was specified as argument....!')

# define string fragments for output later on
outputstring_1 = '''
"""
Custom topology for Mininet, generated by GraphML-Topo-to-Mininet-Network-Generator.
"""
from mininet.topo import Topo
from rau_nodes import RAUSwitch, QuaggaRouter, RAUController, RAUHost
class CustomTopology( Topo ):
    "Internet Topology Zoo Specimen."
    def __init__( self, **opts ):
        "Create a topology."
        # Initialize Topology
        Topo.__init__( self, **opts )
'''

outputstring_2a='''
        # Add controller
'''
outputstring_2a += "        "
outputstring_2a += "root = self.addHost('controller', cls=RAUController, ip='" + controller_ip + "/24')"
outputstring_2a += '''
        # Add management network switch
        man_switch = self.addSwitch('s1', protocols='OpenFlow13', failMode='standalone')
'''
outputstring_2b='''
        # Add switches, hosts and routers
'''

outputstring_3='''
        # Add links between nodes
'''


#WHERE TO PUT RESULTS
outputstring_to_be_exported = ''

#READ FILE AND DO ALL THE ACTUAL PARSING IN THE NEXT PARTS
xml_tree    = ET.parse("topologies/" + input_file_name)
namespace   = "{http://graphml.graphdrawing.org/xmlns}"
ns          = namespace # just doing shortcutting, namespace is needed often.

#GET ALL ELEMENTS THAT ARE PARENTS OF ELEMENTS NEEDED LATER ON
root_element    = xml_tree.getroot()
graph_element   = root_element.find(ns + 'graph')

# GET ALL ELEMENT SETS NEEDED LATER ON
index_values_set    = root_element.findall(ns + 'key')
node_set            = graph_element.findall(ns + 'node')
edge_set            = graph_element.findall(ns + 'edge')

# SET SOME VARIABLES TO SAVE FOUND DATA FIRST
# memomorize the values' ids to search for in current topology
node_label_name_in_graphml = ''
# for saving the current values
node_index_value     = ''
node_name_value      = ''
# id:value dictionaries
id_node_name_dict   = {}     # to hold all 'id: node_name' pairs
edge_with_ip_collection = []         # to hold { node1: IP_ADDRESS1, node2: IP_ADDRESS2 } elements

# FIND OUT WHAT KEY IS USED FOR THE NAME, SINCE THIS DIFFERS IN DIFFERENT GRAPHML TOPOLOGIES
for i in index_values_set:
    if i.attrib['attr.name'] == 'label' and i.attrib['for'] == 'node':
        node_label_name_in_graphml = i.attrib['id']

# INITIALIZE IP ADRESSES LIST
possible_ip_addresses = []
for i in range(1,255):
    possible_ip_addresses.append("10.10." + str(i) + ".")

# INITIALIZE MANAGEMENT IP ADDRESSES
mgmt_ip_addresses = []
for i in range(11,255):
    mgmt_ip_addresses.append("192.168.1." + str(i) + "/24")

# INITIALIZE MAC ADDRESSES LIST (this is only used for border switches)
possible_mac_addresses = []
for i in range(1,255):
    possible_mac_addresses.append("00:00:00:00:00:" + hex(i)[2:])

# NOW PARSE ELEMENT SETS TO GET THE DATA FOR THE TOPO

# GET ID: NODE_NAME MAPPINGS
for n in node_set:

    node_id = n.attrib['id']

    #get all data elements residing under all node elements
    data_set = n.findall(ns + 'data')

    #finally get all needed values
    for d in data_set:

        #node name
        if d.attrib['key'] == node_label_name_in_graphml:
            #strip all whitespace from names so they can be used as id's
            node_name = re.sub(r'\s+', '', d.text)

            #save id:data couple
            id_node_name_dict[node_id] = node_name

# GET COLLECTION OF EDGES
for e in edge_set:
    source_id = e.attrib['source']
    target_id = e.attrib['target']

    ip_address_prefix = possible_ip_addresses.pop(0)
    edge = {}
    edge[source_id] = ip_address_prefix + "1/24"
    edge[target_id] = ip_address_prefix + "2/24"

    edge_with_ip_collection.append(edge)


# NOW THAT THE DATA IS LOADED INTO THE VARIABLES edge_with_ip_collection AND id_node_name_dict
# WE CAN CREATE ALL THE REMAINING STRINGS

# FIRST CREATE THE SWITCHES
tempstring = ""
for i in id_node_name_dict.keys():
    # create switch
    # we assume that the ids are integers so that the switches are named "switchX" being X an integer
    # this is necessary because the datapath-id for the node is the integer extracted from the name
    temp1 =  "        "
    temp1 += id_node_name_dict[i]
    # we add 1 to i while naming the switch because some graphs may have a node with id="0" and the datapath-id can't be 0
    temp1 += " = self.addHost('switch" + str(int(i)+1) + "', loopback='127.0.0.1', controller_ip='" + controller_ip + "', cls=RAUSwitch, "
    temp1 += "ips=["

    # Pop the first available management address and use it for this switch
    mgmt_ip = mgmt_ip_addresses.pop(0)
    temp1 += "'" + mgmt_ip + "'"

    # Iterate over all the edges and get this switch's links and IP addresses
    for edge in edge_with_ip_collection:
        if i in edge.keys():
            temp1 += ",'" + edge[i] + "'"

    temp1 += "])"
    temp1 += "\n"

    # Add this switch to the tempstring variable, holding the switches
    tempstring += temp1

outputstring_2b += tempstring

# NOW CREATE THE LINKS
# FIRST THE MANAGEMENT LINKS
tempstring2 = ""
tempstring2 += "        self.addLink(man_switch, root, 1, 0)\n"
counter = 1
for i in id_node_name_dict.keys():
    temp2 = "        "
    counter += 1
    temp2 += "self.addLink(man_switch, " + id_node_name_dict[i] + ", " + str(counter) + ", 0)\n"

    tempstring2 += temp2

# NEXT, CREATE THE NETWORK LINKS
tempstring3 = ""
for edge in edge_with_ip_collection:
    temp3 = "        "

    source_id = edge.keys()[0]
    target_id = edge.keys()[1]

    # we need to iterate over all the edges before this one to know what number of link this is
    # for each of the nodes
    # start at 1 because they already have one link with the management switch
    source_counter = 1
    target_counter = 1

    for e2 in edge_with_ip_collection:
        if e2 == edge:
            break
        else:
            if source_id in e2.keys():
                source_counter += 1
            if target_id in e2.keys():
                target_counter += 1

    temp3 += "self.addLink(" + id_node_name_dict[source_id] + ", " + id_node_name_dict[target_id] + ", " + str(source_counter) + ", " + str(target_counter) + ")\n"

    tempstring3 += temp3

outputstring_3 += tempstring2
outputstring_3 += tempstring3

outputstring_to_be_exported += outputstring_1
outputstring_to_be_exported += outputstring_2a
outputstring_to_be_exported += outputstring_2b
outputstring_to_be_exported += outputstring_3

# GENERATION FINISHED, WRITE STRING TO FILE
if output_file_name == '':
    output_file_name = input_file_name + '-generated-Mininet-Topo.py'

outputfile = open("topologies/" + output_file_name, 'w')
outputfile.write(outputstring_to_be_exported)
outputfile.close()

print "Topology generation SUCCESSFUL!"